<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas - Creative Technologist Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --gold: #d4af37;
            --cream: #fceea7;
        }
        body {
            margin: 0;
            background-color: #000;
            color: white;
            font-family: 'Times New Roman', serif;
            overflow: hidden;
            user-select: none;
        }

        /* UI Components */
        #loader {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 1s ease;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(212, 175, 55, 0.1);
            border-top: 1px solid var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #loader p {
            letter-spacing: 4px;
            font-size: 12px;
            color: var(--gold);
        }

        .ui-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 100;
            transition: opacity 0.5s ease;
        }
        .ui-hidden { opacity: 0; pointer-events: none; }

        h1 {
            position: absolute;
            top: 5%;
            width: 100%;
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: 56px;
            margin: 0;
            background: linear-gradient(to bottom, #ffffff, var(--gold));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(212, 175, 55, 0.5));
        }

        .upload-wrapper {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            text-align: center;
        }
        .btn-upload {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 12px 30px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            transition: all 0.3s;
        }
        .btn-upload:hover { background: rgba(212, 175, 55, 0.2); }
        .hint {
            display: block;
            margin-top: 10px;
            font-size: 10px;
            opacity: 0.6;
            color: var(--cream);
        }

        #webcam-container {
            position: fixed;
            bottom: 10px;
            right: 10px;
            opacity: 0; /* Hidden as per spec */
            pointer-events: none;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
        }
    }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <p>LOADING HOLIDAY MAGIC</p>
    </div>

    <div class="ui-container" id="gui">
        <h1>Merry Christmas</h1>
        <div class="upload-wrapper">
            <button class="btn-upload" onclick="document.getElementById('imgInput').click()">ADD MEMORIES</button>
            <input type="file" id="imgInput" hidden accept="image/*">
            <span class="hint">Press 'H' to Hide Controls</span>
        </div>
    </div>

    <div id="webcam-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="cv-canvas" width="160" height="120"></canvas>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { HandLandmarker, FilesetResolver } from '@mediapipe/tasks-vision';

        // --- State Management ---
        const STATE = {
            mode: 'TREE', // TREE, SCATTER, FOCUS
            handRotation: { x: 0, y: 0 },
            focusedObject: null,
            particles: []
        };

        // --- Core Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.2;
        document.body.appendChild(renderer.domElement);

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // --- Post Processing ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.45, 0.4, 0.7);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Environment & Lights ---
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const pLight = new THREE.PointLight(0xffaa44, 2, 50);
        pLight.position.set(0, 5, 0);
        scene.add(pLight);

        const spot1 = new THREE.SpotLight(0xd4af37, 1200);
        spot1.position.set(30, 40, 40);
        scene.add(spot1);

        const spot2 = new THREE.SpotLight(0x4466ff, 600);
        spot2.position.set(-30, 20, -30);
        scene.add(spot2);

        // --- Utilities ---
        const createCandyCaneTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 128, 128);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 20;
            ctx.beginPath();
            for(let i=0; i<5; i++) {
                ctx.moveTo(-50 + i*50, 0);
                ctx.lineTo(150 + i*50, 128);
            }
            ctx.stroke();
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 1);
            return tex;
        };

        // --- Particle Class ---
        class HolidayElement {
            constructor(type) {
                this.type = type;
                let geo, mat;
                
                if(type === 'BOX') {
                    geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    mat = new THREE.MeshStandardMaterial({ color: Math.random() > 0.5 ? 0xd4af37 : 0x0a3d00 });
                } else if(type === 'SPHERE') {
                    geo = new THREE.SphereGeometry(0.5, 24, 24);
                    mat = new THREE.MeshPhysicalMaterial({ 
                        color: Math.random() > 0.5 ? 0xd4af37 : 0xbb0000,
                        clearcoat: 1.0, clearcoatRoughness: 0.1
                    });
                } else if(type === 'CANDY') {
                    const curve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 2, 0),
                        new THREE.Vector3(-0.5, 2.5, 0),
                        new THREE.Vector3(-1, 2, 0)
                    ]);
                    geo = new THREE.TubeGeometry(curve, 20, 0.15, 8, false);
                    mat = new THREE.MeshStandardMaterial({ map: createCandyCaneTexture() });
                }

                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.castShadow = true;
                
                this.targetPos = new THREE.Vector3();
                this.velocity = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.1);
                this.randOffset = Math.random() * Math.PI * 2;
                
                mainGroup.add(this.mesh);
            }

            update(time) {
                if (STATE.mode === 'TREE') {
                    const idx = STATE.particles.indexOf(this);
                    const t = idx / 1500;
                    const radius = 15 * (1 - t);
                    const angle = t * Math.PI * 50;
                    this.targetPos.set(Math.cos(angle) * radius, t * 30 - 15, Math.sin(angle) * radius);
                    this.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                } else if (STATE.mode === 'SCATTER') {
                    const idx = STATE.particles.indexOf(this);
                    if(!this.scatterTarget) {
                        this.scatterTarget = new THREE.Vector3().setFromSphericalCoords(
                            8 + Math.random() * 12, Math.random() * Math.PI, Math.random() * Math.PI * 2
                        );
                    }
                    this.targetPos.copy(this.scatterTarget);
                    this.mesh.rotation.x += this.velocity.x;
                    this.mesh.rotation.y += this.velocity.y;
                    this.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                } else if (STATE.mode === 'FOCUS') {
                    if (this === STATE.focusedObject) {
                        this.targetPos.set(0, 2, 35);
                        this.mesh.scale.lerp(new THREE.Vector3(4.5, 4.5, 4.5), 0.1);
                        this.mesh.rotation.y = Math.sin(time) * 0.2;
                    } else {
                        const idx = STATE.particles.indexOf(this);
                        this.targetPos.set(Math.sin(idx) * 40, Math.cos(idx) * 40, -10);
                        this.mesh.scale.lerp(new THREE.Vector3(0.5, 0.5, 0.5), 0.1);
                    }
                }
                
                this.mesh.position.lerp(this.targetPos, 0.05);
            }
        }

        // --- Photo Wall Logic ---
        function addPhotoToScene(texture) {
            const frameGeo = new THREE.BoxGeometry(4.2, 5.2, 0.2);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            const photoGeo = new THREE.PlaneGeometry(4, 5);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.11;
            frame.add(photo);

            const photoObj = {
                type: 'PHOTO',
                mesh: frame,
                targetPos: new THREE.Vector3(),
                velocity: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.05),
                update: function(time) {
                    if(STATE.mode === 'TREE') {
                        const idx = STATE.particles.indexOf(this);
                        this.targetPos.set(Math.sin(idx)*15, Math.cos(idx)*10, Math.cos(idx)*15);
                        this.mesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                    } else if (STATE.mode === 'FOCUS' && this === STATE.focusedObject) {
                        this.targetPos.set(0, 2, 35);
                        this.mesh.scale.lerp(new THREE.Vector3(3.5, 3.5, 3.5), 0.1);
                        this.mesh.rotation.y = Math.sin(time) * 0.3;
                    } else {
                        const idx = STATE.particles.indexOf(this);
                        this.targetPos.set(Math.sin(idx)*30, Math.cos(idx)*20, -5);
                    }
                    this.mesh.position.lerp(this.targetPos, 0.05);
                }
            };
            
            STATE.particles.push(photoObj);
            mainGroup.add(frame);
        }

        // Default Photo
        const canvasJoy = document.createElement('canvas');
        canvasJoy.width = 400; canvasJoy.height = 500;
        const ctxJ = canvasJoy.getContext('2d');
        ctxJ.fillStyle = '#fceea7'; ctxJ.fillRect(0,0,400,500);
        ctxJ.fillStyle = '#000'; ctxJ.font = 'bold 40px Cinzel';
        ctxJ.textAlign = 'center'; ctxJ.fillText('JOYEUX NOEL', 200, 250);
        addPhotoToScene(new THREE.CanvasTexture(canvasJoy));

        // --- Initialization ---
        async function init() {
            // Create Particles
            for(let i=0; i<1500; i++) {
                const types = ['BOX', 'SPHERE', 'CANDY'];
                STATE.particles.push(new HolidayElement(types[i % 3]));
            }

            // MediaPipe Setup
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            const handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });

            const video = document.getElementById('webcam');
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    document.getElementById('loader').style.opacity = '0';
                    setTimeout(() => document.getElementById('loader').remove(), 1000);
                    predict();
                });
            });

            function predict() {
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];
                    processGestures(landmarks);
                    // Mapping Hand to Scene Rotation
                    STATE.handRotation.y = (landmarks[9].x - 0.5) * 2;
                    STATE.handRotation.x = (landmarks[9].y - 0.5) * 1;
                }
                requestAnimationFrame(predict);
            }

            animate();
        }

        function processGestures(lm) {
            const getDist = (p1, p2) => Math.hypot(lm[p1].x - lm[p2].x, lm[p1].y - lm[p2].y);
            const pinch = getDist(4, 8);
            
            // Calc average distance from fingertips (12,16,20) to wrist (0)
            const openDist = (getDist(8, 0) + getDist(12, 0) + getDist(16, 0) + getDist(20, 0)) / 4;

            if (pinch < 0.05) {
                if(STATE.mode !== 'FOCUS') {
                    STATE.mode = 'FOCUS';
                    const photos = STATE.particles.filter(p => p.type === 'PHOTO');
                    STATE.focusedObject = photos[Math.floor(Math.random() * photos.length)];
                }
            } else if (openDist < 0.25) {
                STATE.mode = 'TREE';
            } else if (openDist > 0.4) {
                STATE.mode = 'SCATTER';
                STATE.particles.forEach(p => p.scatterTarget = null); // Reset scatter points
            }
        }

        function animate() {
            const time = performance.now() * 0.001;
            
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, STATE.handRotation.y, 0.1);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, STATE.handRotation.x, 0.1);

            STATE.particles.forEach(p => p.update(time));

            composer.render();
            requestAnimationFrame(animate);
        }

        // --- Listeners ---
        window.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'h') {
                document.getElementById('gui').classList.toggle('ui-hidden');
            }
        });

        document.getElementById('imgInput').onchange = (e) => {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    new THREE.TextureLoader().load(ev.target.result, (t) => {
                        t.colorSpace = THREE.SRGBColorSpace;
                        addPhotoToScene(t);
                    });
                }
                reader.readAsDataURL(file);
            }
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>

